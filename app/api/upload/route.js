/**
 * POST /api/upload
 * Handle multipart video upload from frontend
 */

import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import { uploadFile, sendMessage } from '../../../lib/telegram.js';
import { createMetadataMessage } from '../../../lib/schema.js';

// No body parsing by Next.js, we handle it
export const config = {
    api: {
        bodyParser: false,
    },
};

// Disable caching
export const dynamic = 'force-dynamic';

export async function POST(request) {
    try {
        const formData = await request.formData();
        const videoFile = formData.get('video');
        const title = formData.get('title');
        const description = formData.get('description');
        const durationStr = formData.get('duration');
        // const category = formData.get('category'); // Not used in metadata yet

        if (!videoFile) {
            return NextResponse.json(
                { error: 'No video file provided' },
                { status: 400 }
            );
        }

        console.log(`[API /upload] Received upload: ${title} (${videoFile.size} bytes)`);

        // 1. Upload video to Telegram
        // We reuse the FormData structure for Telegram upload
        // but we need to verify if we can pass the File object directly.
        // Node 20+ fetch handling of File/Blob in FormData should work.

        const tgFormData = new FormData();
        tgFormData.append('chat_id', process.env.TELEGRAM_CHANNEL_ID);
        tgFormData.append('video', videoFile, videoFile.name || 'video.mp4');

        const videoResult = await uploadFile(tgFormData, 'video');
        const videoMsgId = videoResult.message_id;

        // Extract file_id
        let fileId = '';
        if (videoResult.video) fileId = videoResult.video.file_id;
        else if (videoResult.document) fileId = videoResult.document.file_id;
        else if (videoResult.animation) fileId = videoResult.animation.file_id;
        else throw new Error('No file_id in Telegram response');

        console.log(`[API /upload] Video uploaded (ID: ${videoMsgId})`);

        // 2. Handle Thumbnail (Auto-generated by Telegram usually)
        // If user provided custom thumb, we would upload it here
        let thumbFileId = '';
        if (videoResult.video?.thumb) {
            thumbFileId = videoResult.video.thumb.file_id;
        }

        // 3. Create Metadata
        const duration = parseInt(durationStr || '0', 10);
        const metadata = createMetadataMessage({
            video_msg_id: videoMsgId,
            file_id: fileId,
            thumb_file_id: thumbFileId,
            title: title || 'Untitled',
            description: description || '',
            duration,
        });

        // 4. Send Metadata to Channel
        await sendMessage(JSON.stringify(metadata, null, 2));
        console.log('[API /upload] Metadata posted');

        // 5. Update Local JSON (Simple implementation)
        const dataDir = path.join(process.cwd(), 'data');
        const videosJsonPath = path.join(dataDir, 'videos.json');

        if (!fs.existsSync(dataDir)) {
            fs.mkdirSync(dataDir, { recursive: true });
        }

        let videos = [];
        if (fs.existsSync(videosJsonPath)) {
            const content = fs.readFileSync(videosJsonPath, 'utf-8');
            videos = JSON.parse(content);
        }

        const newVideo = {
            id: String(videoMsgId),
            title: metadata.title,
            description: metadata.description,
            file_id: metadata.file_id,
            thumb_file_id: metadata.thumb_file_id,
            duration: metadata.duration,
            uploaded_at: metadata.uploaded_at,
        };

        // Add to list and dedup
        videos = videos.filter(v => v.id !== 'demo' && v.id !== String(videoMsgId));
        videos.push(newVideo);

        fs.writeFileSync(videosJsonPath, JSON.stringify(videos, null, 2));
        console.log('[API /upload] Local DB updated');

        return NextResponse.json({ success: true, video: newVideo });

    } catch (error) {
        console.error('[API /upload] Error:', error);
        return NextResponse.json(
            { error: 'Upload failed', details: error.message },
            { status: 500 }
        );
    }
}
